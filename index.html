import React, { useState, useEffect, useRef } from 'react';
import { Wallet, TrendingUp, TrendingDown, Activity, DollarSign, AlertCircle, Settings, Play, Pause, Search, RefreshCw, ExternalLink, Repeat, BarChart3, Target, CheckCircle, XCircle } from 'lucide-react';

const TradingBot = () => {
  const [account, setAccount] = useState(null);
  const [balanceBNB, setBalanceBNB] = useState('0');
  const [balanceUSDT, setBalanceUSDT] = useState('0');
  const [isConnected, setIsConnected] = useState(false);
  const [selectedStrategy, setSelectedStrategy] = useState('scalping');
  const [botRunning, setBotRunning] = useState(false);
  const [trades, setTrades] = useState([]);
  const [cryptoList, setCryptoList] = useState([]);
  const [selectedCrypto, setSelectedCrypto] = useState('BTCUSDT');
  const [currentPrice, setCurrentPrice] = useState(null);
  const [priceChange, setPriceChange] = useState(0);
  const [tradingCapital, setTradingCapital] = useState('');
  const [capitalSet, setCapitalSet] = useState(false);
  const [tradingMode, setTradingMode] = useState('simulation'); // 'simulation' ou 'real'
  const [usdtApproved, setUsdtApproved] = useState(false);
  const [approving, setApproving] = useState(false);
  const [portfolio, setPortfolio] = useState({
    totalValue: 0,
    profit: 0,
    profitPercent: 0,
    commission: 0
  });
  const [settings, setSettings] = useState({
    slippage: 0.5,
    gasPrice: 5,
    tradeAmountPercent: 10,
    stopLoss: 5,
    takeProfit: 10
  });
  
  const [indicators, setIndicators] = useState({
    rsi: 50,
    macd: { value: 0, signal: 0, histogram: 0 },
    ema20: 0,
    ema50: 0,
    bollingerBands: { upper: 0, middle: 0, lower: 0 }
  });
  
  const [priceHistory, setPriceHistory] = useState([]);
  const wsRef = useRef(null);
  const [loading, setLoading] = useState(false);
  const [bnbPrice, setBnbPrice] = useState(620);

  // Contrats et adresses BSC
  const PANCAKE_ROUTER = '0x10ED43C718714eb63d5aA57B78B54704E256024E';
  const COMMISSION_RATE = 0.0001;
  const COMMISSION_WALLET = '0x3bf6f7bb2fc3fa4685138303fe593fc8b5b475ba';
  const USDT_CONTRACT = '0x55d398326f99059fF775485246999027B3197955';
  const WBNB_CONTRACT = '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c';
  
  // Mapping des symboles Binance vers les adresses BSC (pour trading r√©el)
  const TOKEN_ADDRESSES = {
    'BTCUSDT': '0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c', // BTCB
    'ETHUSDT': '0x2170Ed0880ac9A755fd29B2688956BD959F933F8', // ETH
    'BNBUSDT': '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c', // WBNB
    'ADAUSDT': '0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47', // ADA
    'DOGEUSDT': '0xbA2aE424d960c26247Dd6c32edC70B295c744C43', // DOGE
    'XRPUSDT': '0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE', // XRP
    'DOTUSDT': '0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402', // DOT
    'UNIUSDT': '0xBf5140A22578168FD562DCcF235E5D43A02ce9B1', // UNI
    'LINKUSDT': '0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD', // LINK
    'MATICUSDT': '0xCC42724C6683B7E57334c4E856f4c9965ED682bD', // MATIC
    'LTCUSDT': '0x4338665CBB7B2485A8855A139b75D5e34AB0DB94', // LTC
    'SOLUSDT': '0x570A5D26f7765Ecb712C0924E4De545B89fD43dF', // SOL
    'AVAXUSDT': '0x1CE0c2827e2eF14D5C4f29a091d735A204794041', // AVAX
    'TRXUSDT': '0x85EAC5Ac2F758618dFa09bDbe0cf174e7d574D5B', // TRX
    'ATOMUSDT': '0x0Eb3a705fc54725037CC9e008bDede697f62F335', // ATOM
    'EOSUSDT': '0x56b6fB708fC5732DEC1Afc8D8556423A2EDcCbD6', // EOS
    'XLMUSDT': '0x16939ef78684453bfDFb47825F8a5F714f12623a', // XLM
    'AAVEUSDT': '0xfb6115445Bff7b52FeB98650C87f44907E58f802', // AAVE
    'VETUSDT': '0x6FDcdfef7c496407cCb0cEC90f9C5Aaa1Cc8D888', // VET
    'FILUSDT': '0x0D8Ce2A99Bb6e3B7Db580eD848240e4a0F9aE153', // FIL
  };
  
  const [totalCommissionBNB, setTotalCommissionBNB] = useState(0);

  const strategies = {
    scalping: {
      name: 'Scalping',
      description: 'Trading rapide bas√© sur RSI et MACD',
      risk: 'Moyen',
      timeframe: '1-5 min',
      minTradeInterval: 30000,
      indicators: ['RSI', 'MACD', 'Volume']
    },
    swing: {
      name: 'Swing Trading',
      description: 'Positions sur plusieurs jours avec EMA',
      risk: 'Faible',
      timeframe: '1-7 jours',
      minTradeInterval: 300000,
      indicators: ['EMA 20/50', 'RSI', 'Bollinger Bands']
    },
    arbitrage: {
      name: 'Arbitrage',
      description: 'Exploite les diff√©rences de prix entre DEX',
      risk: 'Faible',
      timeframe: 'Instantan√©',
      minTradeInterval: 60000,
      indicators: ['Prix Multi-DEX', 'Liquidit√©']
    },
    grid: {
      name: 'Grid Trading',
      description: 'Niveaux de prix automatiques',
      risk: 'Moyen',
      timeframe: 'Continu',
      minTradeInterval: 120000,
      indicators: ['Niveaux de prix', 'Volatilit√©']
    }
  };

  // Calcul du RSI
  const calculateRSI = (prices, period = 14) => {
    if (prices.length < period + 1) return 50;
    
    let gains = 0;
    let losses = 0;
    
    for (let i = prices.length - period; i < prices.length; i++) {
      const change = prices[i] - prices[i - 1];
      if (change > 0) gains += change;
      else losses += Math.abs(change);
    }
    
    const avgGain = gains / period;
    const avgLoss = losses / period;
    
    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  };

  const calculateMACD = (prices) => {
    if (prices.length < 26) return { value: 0, signal: 0, histogram: 0 };
    
    const ema12 = calculateEMA(prices, 12);
    const ema26 = calculateEMA(prices, 26);
    const macdLine = ema12 - ema26;
    const signalLine = macdLine * 0.9;
    
    return {
      value: macdLine,
      signal: signalLine,
      histogram: macdLine - signalLine
    };
  };

  const calculateEMA = (prices, period) => {
    if (prices.length < period) return prices[prices.length - 1];
    
    const multiplier = 2 / (period + 1);
    let ema = prices.slice(0, period).reduce((a, b) => a + b) / period;
    
    for (let i = period; i < prices.length; i++) {
      ema = (prices[i] - ema) * multiplier + ema;
    }
    
    return ema;
  };

  const calculateBollingerBands = (prices, period = 20, stdDev = 2) => {
    if (prices.length < period) {
      const currentPrice = prices[prices.length - 1];
      return { upper: currentPrice * 1.02, middle: currentPrice, lower: currentPrice * 0.98 };
    }
    
    const recentPrices = prices.slice(-period);
    const middle = recentPrices.reduce((a, b) => a + b) / period;
    
    const variance = recentPrices.reduce((sum, price) => sum + Math.pow(price - middle, 2), 0) / period;
    const standardDeviation = Math.sqrt(variance);
    
    return {
      upper: middle + (standardDeviation * stdDev),
      middle: middle,
      lower: middle - (standardDeviation * stdDev)
    };
  };

  useEffect(() => {
    if (priceHistory.length > 0) {
      const rsi = calculateRSI(priceHistory);
      const macd = calculateMACD(priceHistory);
      const ema20 = calculateEMA(priceHistory, 20);
      const ema50 = calculateEMA(priceHistory, 50);
      const bollingerBands = calculateBollingerBands(priceHistory);
      
      setIndicators({
        rsi,
        macd,
        ema20,
        ema50,
        bollingerBands
      });
    }
  }, [priceHistory]);

  const getTradeSignal = () => {
    const { rsi, macd, ema20, ema50, bollingerBands } = indicators;
    const currentP = currentPrice;
    
    switch (selectedStrategy) {
      case 'scalping':
        if (rsi < 30 && macd.histogram > 0) return { signal: 'BUY', confidence: 0.8 };
        if (rsi > 70 && macd.histogram < 0) return { signal: 'SELL', confidence: 0.8 };
        break;
        
      case 'swing':
        if (ema20 > ema50 && rsi > 45 && rsi < 65) return { signal: 'BUY', confidence: 0.7 };
        if (ema20 < ema50 && rsi > 35 && rsi < 55) return { signal: 'SELL', confidence: 0.7 };
        break;
        
      case 'arbitrage':
        const priceVariation = Math.abs((currentP - bollingerBands.middle) / bollingerBands.middle);
        if (priceVariation > 0.005) {
          return { 
            signal: currentP < bollingerBands.middle ? 'BUY' : 'SELL', 
            confidence: 0.9 
          };
        }
        break;
        
      case 'grid':
        if (currentP <= bollingerBands.lower * 1.01) return { signal: 'BUY', confidence: 0.75 };
        if (currentP >= bollingerBands.upper * 0.99) return { signal: 'SELL', confidence: 0.75 };
        break;
    }
    
    return { signal: null, confidence: 0 };
  };

  useEffect(() => {
    const fetchBNBPrice = async () => {
      try {
        const response = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=BNBUSDT');
        const data = await response.json();
        setBnbPrice(parseFloat(data.price));
      } catch (error) {
        console.error('Erreur prix BNB:', error);
      }
    };
    
    fetchBNBPrice();
    const interval = setInterval(fetchBNBPrice, 10000);
    
    return () => clearInterval(interval);
  }, []);

  const fetchCryptoList = async () => {
    setLoading(true);
    try {
      const response = await fetch('https://api.binance.com/api/v3/ticker/24hr');
      
      if (!response.ok) {
        throw new Error('Erreur API Binance');
      }
      
      const data = await response.json();
      
      console.log('Donn√©es Binance re√ßues:', data.length, 'paires');
      
      // Charger TOUTES les paires USDT populaires
      const usdtPairs = data
        .filter(item => {
          return item.symbol.endsWith('USDT') && 
                 !item.symbol.includes('UP') && 
                 !item.symbol.includes('DOWN') &&
                 !item.symbol.includes('BULL') &&
                 !item.symbol.includes('BEAR') &&
                 parseFloat(item.volume) > 0;
        })
        .map(item => ({
          symbol: item.symbol,
          name: item.symbol.replace('USDT', ''),
          price: parseFloat(item.lastPrice),
          priceChange: parseFloat(item.priceChangePercent),
          volume: parseFloat(item.quoteVolume),
          high24h: parseFloat(item.highPrice),
          low24h: parseFloat(item.lowPrice),
          address: TOKEN_ADDRESSES[item.symbol] || null,
          realTradingAvailable: !!TOKEN_ADDRESSES[item.symbol]
        }))
        .sort((a, b) => b.volume - a.volume)
        .slice(0, 150); // Top 150 par volume
      
      console.log('Cryptos filtr√©es:', usdtPairs.length);
      
      if (usdtPairs.length > 0) {
        setCryptoList(usdtPairs);
      } else {
        throw new Error('Aucune crypto trouv√©e');
      }
      
    } catch (error) {
      console.error('Erreur lors du chargement des cryptos:', error);
      // Fallback avec plus de donn√©es
      const fallbackData = [
        { symbol: 'BTCUSDT', name: 'BTC', price: 89500, priceChange: 2.5, volume: 1000000000, high24h: 90000, low24h: 88000, address: TOKEN_ADDRESSES['BTCUSDT'], realTradingAvailable: true },
        { symbol: 'ETHUSDT', name: 'ETH', price: 3200, priceChange: 1.8, volume: 800000000, high24h: 3250, low24h: 3150, address: TOKEN_ADDRESSES['ETHUSDT'], realTradingAvailable: true },
        { symbol: 'BNBUSDT', name: 'BNB', price: 620, priceChange: 3.2, volume: 500000000, high24h: 630, low24h: 610, address: TOKEN_ADDRESSES['BNBUSDT'], realTradingAvailable: true },
        { symbol: 'SOLUSDT', name: 'SOL', price: 210, priceChange: -1.2, volume: 400000000, high24h: 215, low24h: 205, address: TOKEN_ADDRESSES['SOLUSDT'], realTradingAvailable: true },
        { symbol: 'ADAUSDT', name: 'ADA', price: 1.05, priceChange: 0.8, volume: 350000000, high24h: 1.08, low24h: 1.02, address: TOKEN_ADDRESSES['ADAUSDT'], realTradingAvailable: true },
        { symbol: 'XRPUSDT', name: 'XRP', price: 0.65, priceChange: 1.5, volume: 300000000, high24h: 0.67, low24h: 0.63, address: TOKEN_ADDRESSES['XRPUSDT'], realTradingAvailable: true },
        { symbol: 'DOGEUSDT', name: 'DOGE', price: 0.095, priceChange: -0.5, volume: 250000000, high24h: 0.097, low24h: 0.093, address: TOKEN_ADDRESSES['DOGEUSDT'], realTradingAvailable: true },
        { symbol: 'DOTUSDT', name: 'DOT', price: 7.8, priceChange: 2.1, volume: 200000000, high24h: 8.0, low24h: 7.6, address: TOKEN_ADDRESSES['DOTUSDT'], realTradingAvailable: true },
        { symbol: 'MATICUSDT', name: 'MATIC', price: 1.15, priceChange: 1.2, volume: 180000000, high24h: 1.18, low24h: 1.12, address: TOKEN_ADDRESSES['MATICUSDT'], realTradingAvailable: true },
        { symbol: 'LINKUSDT', name: 'LINK', price: 15.5, priceChange: 0.9, volume: 170000000, high24h: 15.8, low24h: 15.2, address: TOKEN_ADDRESSES['LINKUSDT'], realTradingAvailable: true },
        { symbol: 'AVAXUSDT', name: 'AVAX', price: 42.5, priceChange: -0.8, volume: 160000000, high24h: 43.2, low24h: 41.8, address: TOKEN_ADDRESSES['AVAXUSDT'], realTradingAvailable: true },
        { symbol: 'UNIUSDT', name: 'UNI', price: 8.9, priceChange: 1.7, volume: 150000000, high24h: 9.1, low24h: 8.7, address: TOKEN_ADDRESSES['UNIUSDT'], realTradingAvailable: true },
        { symbol: 'LTCUSDT', name: 'LTC', price: 105, priceChange: 0.5, volume: 140000000, high24h: 107, low24h: 103, address: TOKEN_ADDRESSES['LTCUSDT'], realTradingAvailable: true },
        { symbol: 'TRXUSDT', name: 'TRX', price: 0.18, priceChange: 0.3, volume: 130000000, high24h: 0.19, low24h: 0.17, address: TOKEN_ADDRESSES['TRXUSDT'], realTradingAvailable: true },
        { symbol: 'ATOMUSDT', name: 'ATOM', price: 12.3, priceChange: -0.2, volume: 120000000, high24h: 12.5, low24h: 12.1, address: TOKEN_ADDRESSES['ATOMUSDT'], realTradingAvailable: true },
        { symbol: 'SHIBUSDT', name: 'SHIB', price: 0.000024, priceChange: -1.5, volume: 110000000, high24h: 0.000025, low24h: 0.000023, address: null, realTradingAvailable: false },
        { symbol: 'PEPEUSDT', name: 'PEPE', price: 0.00000185, priceChange: 3.2, volume: 100000000, high24h: 0.00000190, low24h: 0.00000180, address: null, realTradingAvailable: false },
        { symbol: 'ARBUSDT', name: 'ARB', price: 0.95, priceChange: 2.5, volume: 95000000, high24h: 0.98, low24h: 0.92, address: null, realTradingAvailable: false },
        { symbol: 'OPUSDT', name: 'OP', price: 2.45, priceChange: 1.8, volume: 90000000, high24h: 2.50, low24h: 2.40, address: null, realTradingAvailable: false },
        { symbol: 'APTUSDT', name: 'APT', price: 11.8, priceChange: -0.5, volume: 85000000, high24h: 12.1, low24h: 11.5, address: null, realTradingAvailable: false },
      ];
      setCryptoList(fallbackData);
      alert('Impossible de charger les donn√©es Binance. Utilisation des donn√©es de secours.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (selectedCrypto) {
      console.log('Initialisation WebSocket pour:', selectedCrypto);
      
      if (wsRef.current) {
        wsRef.current.close();
      }

      const symbol = selectedCrypto.toLowerCase();
      const wsUrl = `wss://stream.binance.com:9443/ws/${symbol}@ticker`;
      console.log('Connexion WebSocket:', wsUrl);
      
      const ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        console.log('WebSocket connect√© pour', selectedCrypto);
      };
      
      ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        const newPrice = parseFloat(data.c);
        console.log('Prix re√ßu pour', selectedCrypto, ':', newPrice);
        setCurrentPrice(newPrice);
        setPriceChange(parseFloat(data.P));
        
        setPriceHistory(prev => {
          const updated = [...prev, newPrice];
          return updated.slice(-100);
        });
      };

      ws.onerror = (error) => {
        console.error('Erreur WebSocket:', error);
        const fallbackPrice = cryptoList.find(c => c.symbol === selectedCrypto)?.price || 100;
        console.log('Utilisation du prix de secours:', fallbackPrice);
        setCurrentPrice(fallbackPrice);
        setPriceHistory(prev => [...prev, fallbackPrice].slice(-100));
      };
      
      ws.onclose = () => {
        console.log('WebSocket ferm√© pour', selectedCrypto);
      };

      wsRef.current = ws;

      return () => {
        console.log('Nettoyage WebSocket pour', selectedCrypto);
        if (ws.readyState === WebSocket.OPEN) {
          ws.close();
        }
      };
    }
  }, [selectedCrypto, cryptoList]);

  useEffect(() => {
    fetchCryptoList();
  }, []);

  // S√©lectionner automatiquement la premi√®re crypto apr√®s chargement
  useEffect(() => {
    if (cryptoList.length > 0 && !selectedCrypto) {
      console.log('S√©lection automatique de la premi√®re crypto:', cryptoList[0].symbol);
      setSelectedCrypto(cryptoList[0].symbol);
    }
  }, [cryptoList, selectedCrypto]);

  const getUSDTBalance = async (address) => {
    try {
      const data = '0x70a08231' + address.slice(2).padStart(64, '0');
      
      const balance = await window.ethereum.request({
        method: 'eth_call',
        params: [{
          to: USDT_CONTRACT,
          data: data
        }, 'latest']
      });
      
      const balanceUSDT = (parseInt(balance, 16) / 1e18).toFixed(2);
      return balanceUSDT;
    } catch (error) {
      console.error('Erreur lecture USDT:', error);
      return '0';
    }
  };

  const connectWallet = async () => {
    if (typeof window.ethereum !== 'undefined') {
      try {
        const accounts = await window.ethereum.request({ 
          method: 'eth_requestAccounts' 
        });
        
        const chainId = await window.ethereum.request({ 
          method: 'eth_chainId' 
        });
        
        if (chainId !== '0x38') {
          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: '0x38' }],
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: '0x38',
                  chainName: 'BNB Smart Chain',
                  nativeCurrency: {
                    name: 'BNB',
                    symbol: 'BNB',
                    decimals: 18
                  },
                  rpcUrls: ['https://bsc-dataseed1.binance.org'],
                  blockExplorerUrls: ['https://bscscan.com']
                }]
              });
            }
          }
        }
        
        const balanceResult = await window.ethereum.request({
          method: 'eth_getBalance',
          params: [accounts[0], 'latest']
        });
        const bnbBalance = (parseInt(balanceResult, 16) / 1e18).toFixed(4);
        
        const usdtBalance = await getUSDTBalance(accounts[0]);
        
        setAccount(accounts[0]);
        setBalanceBNB(bnbBalance);
        setBalanceUSDT(usdtBalance);
        setIsConnected(true);
        
        // Recharger les cryptos apr√®s connexion
        console.log('Wallet connect√©, rechargement des cryptos...');
        setTimeout(() => {
          fetchCryptoList();
        }, 500);
        
      } catch (error) {
        console.error('Erreur de connexion:', error);
        alert('Erreur lors de la connexion √† MetaMask: ' + error.message);
      }
    } else {
      alert('MetaMask n\'est pas install√©. Veuillez installer MetaMask depuis https://metamask.io');
      window.open('https://metamask.io/download/', '_blank');
    }
  };

  useEffect(() => {
    if (typeof window.ethereum !== 'undefined') {
      window.ethereum.on('accountsChanged', async (accounts) => {
        if (accounts.length === 0) {
          setIsConnected(false);
          setAccount(null);
          setBalanceBNB('0');
          setBalanceUSDT('0');
        } else {
          setAccount(accounts[0]);
          
          const balanceResult = await window.ethereum.request({
            method: 'eth_getBalance',
            params: [accounts[0], 'latest']
          });
          const bnbBalance = (parseInt(balanceResult, 16) / 1e18).toFixed(4);
          const usdtBalance = await getUSDTBalance(accounts[0]);
          
          setBalanceBNB(bnbBalance);
          setBalanceUSDT(usdtBalance);
        }
      });

      window.ethereum.on('chainChanged', () => {
        window.location.reload();
      });
    }
  }, []);

  // Approuver USDT pour PancakeSwap
  const approveUSDT = async () => {
    if (!isConnected) {
      alert('Veuillez connecter votre wallet');
      return;
    }

    try {
      setApproving(true);
      
      // Montant maximum uint256
      const maxAmount = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
      
      // ABI approve(address spender, uint256 amount)
      const approveData = '0x095ea7b3' + 
        PANCAKE_ROUTER.slice(2).padStart(64, '0') +
        maxAmount.slice(2);
      
      const txHash = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [{
          from: account,
          to: USDT_CONTRACT,
          data: approveData,
          gas: '0x186A0', // 100000
        }]
      });
      
      alert('Approbation en cours... TX: ' + txHash);
      
      // Attendre confirmation
      await waitForTransaction(txHash);
      
      setUsdtApproved(true);
      alert('‚úÖ USDT approuv√© pour PancakeSwap !');
      
    } catch (error) {
      console.error('Erreur approbation:', error);
      alert('Erreur lors de l\'approbation: ' + error.message);
    } finally {
      setApproving(false);
    }
  };

  // Attendre confirmation transaction
  const waitForTransaction = async (txHash) => {
    return new Promise((resolve, reject) => {
      const checkInterval = setInterval(async () => {
        try {
          const receipt = await window.ethereum.request({
            method: 'eth_getTransactionReceipt',
            params: [txHash]
          });
          
          if (receipt) {
            clearInterval(checkInterval);
            if (receipt.status === '0x1') {
              resolve(receipt);
            } else {
              reject(new Error('Transaction √©chou√©e'));
            }
          }
        } catch (error) {
          clearInterval(checkInterval);
          reject(error);
        }
      }, 2000);
    });
  };

  // Ex√©cuter un swap sur PancakeSwap
  const executeSwap = async (tradeType, amountUSDT) => {
    if (!isConnected || !usdtApproved) {
      alert('Veuillez approuver USDT d\'abord');
      return;
    }

    try {
      const tokenAddress = TOKEN_ADDRESSES[selectedCrypto];
      if (!tokenAddress) {
        alert('Token non support√© pour le trading r√©el');
        return;
      }

      // Montant avec 18 d√©cimales
      const amountIn = BigInt(Math.floor(amountUSDT * 1e18)).toString(16);
      const amountInHex = '0x' + amountIn.padStart(64, '0');
      
      // Calcul amountOutMin avec slippage
      const expectedOut = (amountUSDT / currentPrice) * (1 - settings.slippage / 100);
      const amountOutMin = BigInt(Math.floor(expectedOut * 1e18)).toString(16);
      const amountOutMinHex = '0x' + amountOutMin.padStart(64, '0');
      
      // Deadline (20 minutes)
      const deadline = Math.floor(Date.now() / 1000) + 1200;
      const deadlineHex = '0x' + deadline.toString(16).padStart(64, '0');
      
      let path, functionSelector;
      
      if (tradeType === 'BUY') {
        // swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline)
        functionSelector = '0x38ed1739';
        path = [USDT_CONTRACT, tokenAddress];
      } else {
        // swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline)
        functionSelector = '0x38ed1739';
        path = [tokenAddress, USDT_CONTRACT];
      }
      
      // Encodage du path
      const pathOffset = '0x' + 'a0'.padStart(64, '0'); // Offset vers path array
      const pathLength = '0x' + '02'.padStart(64, '0'); // 2 addresses
      const pathData = path[0].slice(2).padStart(64, '0') + path[1].slice(2).padStart(64, '0');
      
      const swapData = functionSelector +
        amountInHex.slice(2) +
        amountOutMinHex.slice(2) +
        pathOffset.slice(2) +
        account.slice(2).padStart(64, '0') +
        deadlineHex.slice(2) +
        pathLength.slice(2) +
        pathData;
      
      const txHash = await window.ethereum.request({
        method: 'eth_sendTransaction',
        params: [{
          from: account,
          to: PANCAKE_ROUTER,
          data: swapData,
          gas: '0x493E0', // 300000
        }]
      });
      
      return txHash;
      
    } catch (error) {
      console.error('Erreur swap:', error);
      throw error;
    }
  };

  const openDCASwap = () => {
    window.open('https://reboot17.vercel.app/', '_blank');
  };

  const calculateCommission = (amountUSDT) => {
    const commissionUSDT = amountUSDT * COMMISSION_RATE;
    const commissionBNB = commissionUSDT / bnbPrice;
    return { commissionUSDT, commissionBNB };
  };

  const setCapital = () => {
    const capital = parseFloat(tradingCapital);
    if (capital > 0 && capital <= parseFloat(balanceUSDT)) {
      setCapitalSet(true);
    } else {
      alert(`Veuillez entrer un capital valide (max: ${balanceUSDT} USDT)`);
    }
  };

  const toggleBot = () => {
    console.log('toggleBot appel√©');
    console.log('isConnected:', isConnected);
    console.log('capitalSet:', capitalSet);
    console.log('tradingMode:', tradingMode);
    console.log('currentPrice:', currentPrice);
    console.log('selectedCrypto:', selectedCrypto);
    
    if (!isConnected) {
      alert('‚ùå Veuillez connecter votre wallet MetaMask d\'abord');
      return;
    }
    
    if (!capitalSet) {
      alert('‚ùå Veuillez d√©finir votre capital de trading en USDT');
      return;
    }
    
    if (!currentPrice || currentPrice === 0) {
      alert('‚ùå Attendez que les prix se chargent... Prix actuel: ' + currentPrice);
      return;
    }
    
    if (tradingMode === 'real') {
      const crypto = cryptoList.find(c => c.symbol === selectedCrypto);
      console.log('Crypto trouv√©e:', crypto);
      
      if (!crypto?.realTradingAvailable) {
        alert('‚ö†Ô∏è Trading r√©el non disponible pour ' + selectedCrypto + '. Veuillez choisir une autre crypto (avec üíé) ou passer en mode simulation.');
        setTradingMode('simulation');
        return;
      }
      
      if (!usdtApproved) {
        alert('‚ùå Veuillez d\'abord approuver USDT pour le trading r√©el. Cliquez sur le bouton "Approuver USDT" ci-dessous.');
        return;
      }
    }
    
    console.log('Toutes les v√©rifications pass√©es, changement de botRunning');
    setBotRunning(!botRunning);
    
    if (!botRunning) {
      alert('‚úÖ Bot d√©marr√© en mode ' + (tradingMode === 'real' ? 'R√âEL üíé' : 'SIMULATION üéÆ'));
    } else {
      alert('‚è∏Ô∏è Bot arr√™t√©');
    }
  };

  const lastTradeTimeRef = useRef(0);

  useEffect(() => {
    if (botRunning && currentPrice && priceHistory.length > 50) {
      const strategy = strategies[selectedStrategy];
      
      const interval = setInterval(async () => {
        const now = Date.now();
        
        if (now - lastTradeTimeRef.current < strategy.minTradeInterval) {
          return;
        }
        
        const tradeSignal = getTradeSignal();
        
        if (tradeSignal.signal && tradeSignal.confidence > 0.65) {
          const tradeType = tradeSignal.signal;
          const priceVariation = (Math.random() * 0.005 - 0.0025);
          const executionPrice = currentPrice * (1 + priceVariation);
          
          const tradeAmountUSDT = (parseFloat(tradingCapital) * settings.tradeAmountPercent) / 100;
          
          let txHash = null;
          let tradeStatus = 'completed';
          
          // Mode trading r√©el
          if (tradingMode === 'real') {
            try {
              txHash = await executeSwap(tradeType, tradeAmountUSDT);
              tradeStatus = 'pending';
              
              // Attendre confirmation
              await waitForTransaction(txHash);
              tradeStatus = 'completed';
              
              // Actualiser les soldes
              const usdtBalance = await getUSDTBalance(account);
              setBalanceUSDT(usdtBalance);
              
            } catch (error) {
              console.error('Erreur trade r√©el:', error);
              tradeStatus = 'failed';
              alert('‚ùå Trade √©chou√©: ' + error.message);
              return;
            }
          }
          
          const profitPercent = tradeType === 'BUY' 
            ? (currentPrice - executionPrice) / executionPrice * 100
            : (executionPrice - currentPrice) / currentPrice * 100;
          
          const grossProfitUSDT = tradeAmountUSDT * (profitPercent / 100);
          const { commissionUSDT, commissionBNB } = calculateCommission(tradeAmountUSDT);
          const netProfitUSDT = grossProfitUSDT - commissionUSDT;
          
          const newTrade = {
            id: Date.now(),
            time: new Date().toLocaleTimeString(),
            pair: selectedCrypto,
            type: tradeType,
            amount: tradeAmountUSDT.toFixed(2),
            entryPrice: executionPrice.toFixed(selectedCrypto === 'BTCUSDT' ? 2 : 6),
            currentPrice: currentPrice.toFixed(selectedCrypto === 'BTCUSDT' ? 2 : 6),
            profit: netProfitUSDT.toFixed(4),
            commissionBNB: commissionBNB.toFixed(6),
            commissionUSDT: commissionUSDT.toFixed(4),
            profitPercent: profitPercent.toFixed(2),
            status: tradeStatus,
            mode: tradingMode,
            txHash: txHash,
            strategy: strategies[selectedStrategy].name,
            indicators: {
              rsi: indicators.rsi.toFixed(2),
              macd: indicators.macd.histogram.toFixed(4),
              confidence: (tradeSignal.confidence * 100).toFixed(0) + '%'
            }
          };
          
          setTrades(prev => [newTrade, ...prev].slice(0, 50));
          
          setPortfolio(prev => ({
            totalValue: prev.totalValue + parseFloat(netProfitUSDT),
            profit: prev.profit + parseFloat(netProfitUSDT),
            commission: prev.commission + parseFloat(commissionUSDT),
            profitPercent: ((prev.profit + parseFloat(netProfitUSDT)) / parseFloat(tradingCapital) * 100).toFixed(2)
          }));
          
          setTotalCommissionBNB(prev => prev + commissionBNB);
          lastTradeTimeRef.current = now;
        }
      }, 5000);
      
      return () => clearInterval(interval);
    }
  }, [botRunning, currentPrice, selectedCrypto, settings, selectedStrategy, tradingCapital, indicators, priceHistory, bnbPrice, tradingMode, usdtApproved, account]);

  const formatPrice = (price, symbol) => {
    if (price >= 1000) return price.toFixed(2);
    if (price >= 1) return price.toFixed(4);
    if (price >= 0.01) return price.toFixed(6);
    return price.toFixed(8);
  };

  const formatVolume = (volume) => {
    if (volume >= 1000000000) return `$${(volume / 1000000000).toFixed(2)}B`;
    if (volume >= 1000000) return `$${(volume / 1000000).toFixed(2)}M`;
    if (volume >= 1000) return `$${(volume / 1000).toFixed(2)}K`;
    return `$${volume.toFixed(2)}`;
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4 md:p-6">
      <div className="max-w-7xl mx-auto">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-8">
          <div>
            <h1 className="text-3xl md:text-4xl font-bold bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent">
              Bot Trading Multi-Crypto Pro
            </h1>
            <p className="text-gray-400 mt-2">Trading r√©el avec PancakeSwap ‚Ä¢ Indicateurs techniques avanc√©s</p>
          </div>
          
          <div className="flex gap-3">
            <button
              onClick={openDCASwap}
              className="flex items-center gap-2 px-4 py-3 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 rounded-lg font-semibold transition-all"
            >
              <Repeat size={20} />
              DCA/Swap
              <ExternalLink size={16} />
            </button>
            
            <button
              onClick={connectWallet}
              className={`flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all ${
                isConnected
                  ? 'bg-green-600 hover:bg-green-700'
                  : 'bg-gradient-to-r from-yellow-400 to-orange-500 hover:from-yellow-500 hover:to-orange-600'
              }`}
            >
              <Wallet size={20} />
              {isConnected
                ? `${account.slice(0, 6)}...${account.slice(-4)}`
                : 'Connecter MetaMask'
              }
            </button>
          </div>
        </div>

        {/* Menu d√©roulant pour choisir la crypto */}
        {isConnected && (
          <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6 mb-6">
            <div className="flex justify-between items-center mb-4">
              <h3 className="text-xl font-bold">S√©lectionner la Crypto √† Trader</h3>
              <button
                onClick={() => {
                  console.log('Actualisation manuelle des cryptos');
                  fetchCryptoList();
                }}
                disabled={loading}
                className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 rounded-lg transition-all"
              >
                <RefreshCw size={16} className={loading ? 'animate-spin' : ''} />
                {loading ? 'Chargement...' : 'Actualiser'}
              </button>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm text-gray-400 mb-2">
                  Cryptomonnaie {cryptoList.length > 0 && `(${cryptoList.length} disponibles)`}
                </label>
                {loading ? (
                  <div className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-gray-400">
                    Chargement des cryptos...
                  </div>
                ) : cryptoList.length === 0 ? (
                  <div className="w-full bg-slate-700 border border-red-600 rounded-lg px-4 py-3 text-red-400">
                    ‚ö†Ô∏è Aucune crypto charg√©e. Cliquez sur Actualiser.
                  </div>
                ) : (
                  <select
                    value={selectedCrypto}
                    onChange={(e) => {
                      console.log('Crypto s√©lectionn√©e:', e.target.value);
                      setSelectedCrypto(e.target.value);
                    }}
                    className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 focus:outline-none focus:border-yellow-400 text-lg font-semibold cursor-pointer"
                  >
                    {cryptoList.map((crypto) => (
                      <option key={crypto.symbol} value={crypto.symbol}>
                        {crypto.name} - ${formatPrice(crypto.price, crypto.symbol)} ({crypto.priceChange >= 0 ? '+' : ''}{crypto.priceChange.toFixed(2)}%) {crypto.realTradingAvailable ? 'üíé' : 'üéÆ'}
                      </option>
                    ))}
                  </select>
                )}
                <p className="text-xs text-gray-400 mt-2">
                  {cryptoList.length > 0 ? (
                    <>üíé = Trading r√©el OK ‚Ä¢ üéÆ = Simulation uniquement</>
                  ) : (
                    <>Chargement en cours...</>
                  )}
                </p>
                {selectedCrypto && cryptoList.find(c => c.symbol === selectedCrypto) && (
                  <p className="text-xs text-gray-400 mt-1">
                    Volume 24h: {formatVolume(cryptoList.find(c => c.symbol === selectedCrypto)?.volume || 0)}
                  </p>
                )}
              </div>
              
              <div>
                <label className="block text-sm text-gray-400 mb-2">Mode de Trading</label>
                <select
                  value={tradingMode}
                  onChange={(e) => setTradingMode(e.target.value)}
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 focus:outline-none focus:border-yellow-400 text-lg font-semibold cursor-pointer"
                >
                  <option value="simulation">üéÆ Mode Simulation</option>
                  <option value="real" disabled={!cryptoList.find(c => c.symbol === selectedCrypto)?.realTradingAvailable}>
                    üíé Mode R√©el (PancakeSwap) {!cryptoList.find(c => c.symbol === selectedCrypto)?.realTradingAvailable && '- Non disponible'}
                  </option>
                </select>
                <p className="text-xs text-gray-400 mt-2">
                  {tradingMode === 'real' ? '‚ö†Ô∏è Trades r√©els sur PancakeSwap' : '‚úÖ Pas de frais, donn√©es r√©elles'}
                </p>
                {tradingMode === 'real' && !cryptoList.find(c => c.symbol === selectedCrypto)?.realTradingAvailable && (
                  <p className="text-xs text-orange-400 mt-1">
                    ‚ö†Ô∏è Trading r√©el non disponible pour cette crypto
                  </p>
                )}
              </div>
            </div>
          </div>
        )}

        {/* Approbation USDT pour mode r√©el */}
        {isConnected && tradingMode === 'real' && !usdtApproved && (
          <div className="bg-gradient-to-r from-orange-400/20 to-red-500/20 border-2 border-orange-400 rounded-xl p-6 mb-6">
            <h3 className="text-xl font-bold mb-4 flex items-center gap-2">
              <AlertCircle size={24} className="text-orange-400" />
              Approuver USDT pour le Trading R√©el
            </h3>
            <p className="text-gray-300 mb-4">
              Pour trader en mode r√©el sur PancakeSwap, vous devez d'abord approuver le contrat √† utiliser vos USDT.
              <br />
              <span className="text-sm text-gray-400">Cette op√©ration est n√©cessaire une seule fois.</span>
            </p>
            <button
              onClick={approveUSDT}
              disabled={approving}
              className="px-8 py-3 bg-gradient-to-r from-orange-400 to-red-500 hover:from-orange-500 hover:to-red-600 disabled:from-gray-600 disabled:to-gray-700 rounded-lg font-semibold transition-all"
            >
              {approving ? 'Approbation en cours...' : 'Approuver USDT'}
            </button>
          </div>
        )}

        {/* Capital de trading */}
        {isConnected && !capitalSet && (
          <div className="bg-gradient-to-r from-yellow-400/20 to-orange-500/20 border-2 border-yellow-400 rounded-xl p-6 mb-6">
            <h3 className="text-xl font-bold mb-4 flex items-center gap-2">
              <Target size={24} className="text-yellow-400" />
              D√©finir votre capital de trading en USDT
            </h3>
            <p className="text-gray-300 mb-4">
              Entrez le montant en USDT que vous souhaitez utiliser pour le trading automatique.
              <br />
              <span className="text-sm text-gray-400">Solde disponible: {balanceUSDT} USDT</span>
            </p>
            <div className="flex gap-4">
              <input
                type="number"
                value={tradingCapital}
                onChange={(e) => setTradingCapital(e.target.value)}
                placeholder="Ex: 1000"
                step="10"
                className="flex-1 bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 focus:outline-none focus:border-yellow-400"
              />
              <button
                onClick={setCapital}
                className="px-8 py-3 bg-gradient-to-r from-yellow-400 to-orange-500 hover:from-yellow-500 hover:to-orange-600 rounded-lg font-semibold transition-all"
              >
                Valider
              </button>
            </div>
          </div>
        )}

        {isConnected && capitalSet && (
          <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-8">
            <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4 md:p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-gray-400 text-xs md:text-sm">Capital USDT</p>
                  <p className="text-xl md:text-2xl font-bold mt-1 text-green-400">${tradingCapital}</p>
                  <p className="text-xs text-gray-500">Solde: ${balanceUSDT}</p>
                </div>
                <DollarSign className="text-green-400" size={24} />
              </div>
            </div>
            
            <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4 md:p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-gray-400 text-xs md:text-sm">Prix {selectedCrypto.replace('USDT', '')}</p>
                  <p className="text-xl md:text-2xl font-bold mt-1">
                    {currentPrice ? `$${formatPrice(currentPrice, selectedCrypto)}` : '...'}
                  </p>
                </div>
                <TrendingUp className={priceChange >= 0 ? 'text-green-400' : 'text-red-400'} size={24} />
              </div>
            </div>
            
            <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4 md:p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-gray-400 text-xs md:text-sm">Profit Net</p>
                  <p className={`text-xl md:text-2xl font-bold mt-1 ${portfolio.profit >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                    ${portfolio.profit.toFixed(2)}
                  </p>
                  <p className="text-xs text-gray-400">({portfolio.profitPercent}%)</p>
                </div>
                <Activity className="text-blue-400" size={24} />
              </div>
            </div>
            
            <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4 md:p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-gray-400 text-xs md:text-sm">Commission</p>
                  <p className="text-xl md:text-2xl font-bold mt-1 text-purple-400">
                    {totalCommissionBNB.toFixed(6)} BNB
                  </p>
                  <p className="text-xs text-gray-500 mt-1">
                    ‚âà ${portfolio.commission.toFixed(2)}
                  </p>
                </div>
                <Settings className="text-purple-400" size={24} />
              </div>
            </div>
            
            <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-4 md:p-6">
              <div className="flex items-center justify-between">
                <div>
                  <p className="text-gray-400 text-xs md:text-sm">Mode</p>
                  <p className={`text-xl md:text-2xl font-bold mt-1 ${tradingMode === 'real' ? 'text-orange-400' : 'text-blue-400'}`}>
                    {tradingMode === 'real' ? 'üíé R√âEL' : 'üéÆ SIM'}
                  </p>
                  <p className="text-xs text-gray-400">{tradingMode === 'real' ? 'PancakeSwap' : 'Simulation'}</p>
                </div>
                <Activity className={tradingMode === 'real' ? 'text-orange-400' : 'text-blue-400'} size={24} />
              </div>
            </div>
          </div>
        )}

        {/* Indicateurs techniques */}
        {isConnected && capitalSet && priceHistory.length > 50 && (
          <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6 mb-6">
            <h2 className="text-xl font-bold mb-4 flex items-center gap-2">
              <BarChart3 className="text-blue-400" size={24} />
              Indicateurs Techniques - {selectedCrypto.replace('USDT', '')}
            </h2>
            <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
              <div className="bg-slate-700/50 rounded-lg p-4">
                <p className="text-gray-400 text-sm mb-1">RSI (14)</p>
                <p className={`text-2xl font-bold ${
                  indicators.rsi < 30 ? 'text-green-400' : 
                  indicators.rsi > 70 ? 'text-red-400' : 
                  'text-yellow-400'
                }`}>
                  {indicators.rsi.toFixed(2)}
                </p>
                <p className="text-xs text-gray-500 mt-1">
                  {indicators.rsi < 30 ? 'Survendu' : indicators.rsi > 70 ? 'Surachet√©' : 'Neutre'}
                </p>
              </div>
              
              <div className="bg-slate-700/50 rounded-lg p-4">
                <p className="text-gray-400 text-sm mb-1">MACD</p>
                <p className={`text-2xl font-bold ${indicators.macd.histogram >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                  {indicators.macd.histogram.toFixed(4)}
                </p>
                <p className="text-xs text-gray-500 mt-1">
                  {indicators.macd.histogram >= 0 ? 'Haussier' : 'Baissier'}
                </p>
              </div>
              
              <div className="bg-slate-700/50 rounded-lg p-4">
                <p className="text-gray-400 text-sm mb-1">EMA 20</p>
                <p className="text-2xl font-bold text-blue-400">
                  ${formatPrice(indicators.ema20, selectedCrypto)}
                </p>
                <p className="text-xs text-gray-500 mt-1">
                  {currentPrice > indicators.ema20 ? '‚Üë Au-dessus' : '‚Üì En-dessous'}
                </p>
              </div>
              
              <div className="bg-slate-700/50 rounded-lg p-4">
                <p className="text-gray-400 text-sm mb-1">EMA 50</p>
                <p className="text-2xl font-bold text-purple-400">
                  ${formatPrice(indicators.ema50, selectedCrypto)}
                </p>
                <p className="text-xs text-gray-500 mt-1">
                  {indicators.ema20 > indicators.ema50 ? 'Golden Cross' : 'Death Cross'}
                </p>
              </div>
              
              <div className="bg-slate-700/50 rounded-lg p-4">
                <p className="text-gray-400 text-sm mb-1">Bollinger</p>
                <p className="text-sm font-bold text-green-400">‚Üë ${formatPrice(indicators.bollingerBands.upper, selectedCrypto)}</p>
                <p className="text-sm font-bold text-gray-400">‚Ä¢ ${formatPrice(indicators.bollingerBands.middle, selectedCrypto)}</p>
                <p className="text-sm font-bold text-red-400">‚Üì ${formatPrice(indicators.bollingerBands.lower, selectedCrypto)}</p>
              </div>
            </div>
          </div>
        )}

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <div className="lg:col-span-2 space-y-6">
            <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6">
              <h2 className="text-2xl font-bold mb-4">Strat√©gies de Trading</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {Object.entries(strategies).map(([key, strategy]) => (
                  <div
                    key={key}
                    onClick={() => setSelectedStrategy(key)}
                    className={`p-4 rounded-lg border-2 cursor-pointer transition-all ${
                      selectedStrategy === key
                        ? 'border-yellow-400 bg-yellow-400/10'
                        : 'border-slate-600 hover:border-slate-500'
                    }`}
                  >
                    <h3 className="font-bold text-lg mb-2">{strategy.name}</h3>
                    <p className="text-gray-400 text-sm mb-3">{strategy.description}</p>
                    <div className="space-y-1 mb-3">
                      <div className="flex gap-2 flex-wrap">
                        {strategy.indicators.map((ind, idx) => (
                          <span key={idx} className="text-xs bg-blue-400/20 text-blue-400 px-2 py-1 rounded">
                            {ind}
                          </span>
                        ))}
                      </div>
                    </div>
                    <div className="flex justify-between text-sm">
                      <span className="text-gray-500">Risque: <span className="text-yellow-400">{strategy.risk}</span></span>
                      <span className="text-gray-500">{strategy.timeframe}</span>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-2xl font-bold">Historique des Trades</h2>
                <button
                  onClick={toggleBot}
                  disabled={!isConnected || !capitalSet || loading}
                  className={`flex items-center gap-2 px-6 py-2 rounded-lg font-semibold transition-all ${
                    botRunning
                      ? 'bg-red-600 hover:bg-red-700'
                      : 'bg-green-600 hover:bg-green-700 disabled:bg-gray-600 disabled:cursor-not-allowed'
                  }`}
                  title={!isConnected ? 'Connectez votre wallet' : !capitalSet ? 'D√©finissez votre capital' : botRunning ? 'Arr√™ter le bot' : 'D√©marrer le bot'}
                >
                  {botRunning ? <Pause size={20} /> : <Play size={20} />}
                  {botRunning ? 'Arr√™ter' : 'D√©marrer'}
                </button>
              </div>
              
              {trades.length === 0 ? (
                <div className="text-center py-8 text-gray-400">
                  <AlertCircle className="mx-auto mb-2" size={48} />
                  <p>Aucun trade pour le moment</p>
                  <p className="text-sm mt-2">D√©marrez le bot pour commencer</p>
                </div>
              ) : (
                <div className="space-y-2 max-h-96 overflow-y-auto">
                  {trades.map((trade) => (
                    <div
                      key={trade.id}
                      className="flex items-center justify-between p-4 bg-slate-700/50 rounded-lg"
                    >
                      <div className="flex items-center gap-4">
                        {trade.type === 'BUY' ? (
                          <TrendingUp className="text-green-400" size={24} />
                        ) : (
                          <TrendingDown className="text-red-400" size={24} />
                        )}
                        <div>
                          <div className="flex items-center gap-2">
                            <p className="font-semibold">{trade.pair.replace('USDT', '')}/USDT</p>
                            {trade.mode === 'real' && (
                              trade.status === 'completed' ? (
                                <CheckCircle className="text-green-400" size={16} />
                              ) : trade.status === 'failed' ? (
                                <XCircle className="text-red-400" size={16} />
                              ) : (
                                <RefreshCw className="text-yellow-400 animate-spin" size={16} />
                              )
                            )}
                            {trade.mode === 'real' && <span className="text-xs bg-orange-400/20 text-orange-400 px-2 py-0.5 rounded">R√âEL</span>}
                          </div>
                          <p className="text-xs text-gray-400">{trade.time} ‚Ä¢ {trade.strategy} ‚Ä¢ ${trade.amount}</p>
                          <p className="text-xs text-blue-400">
                            RSI: {trade.indicators.rsi} | MACD: {trade.indicators.macd} | Conf: {trade.indicators.confidence}
                          </p>
                          {trade.txHash && (
                            <a 
                              href={`https://bscscan.com/tx/${trade.txHash}`}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="text-xs text-purple-400 hover:underline flex items-center gap-1"
                            >
                              Voir TX <ExternalLink size={12} />
                            </a>
                          )}
                        </div>
                      </div>
                      <div className="text-right">
                        <p className="text-sm">${trade.entryPrice}</p>
                        <p className={`text-sm font-semibold ${parseFloat(trade.profit) >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                          {parseFloat(trade.profit) >= 0 ? '+' : ''}${trade.profit}
                        </p>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>

          <div className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl p-6">
            <h2 className="text-2xl font-bold mb-4">Param√®tres</h2>
            
            <div className="space-y-4">
              <div>
                <label className="block text-sm text-gray-400 mb-2">
                  % du capital par trade
                </label>
                <input
                  type="number"
                  value={settings.tradeAmountPercent}
                  onChange={(e) => setSettings({...settings, tradeAmountPercent: parseFloat(e.target.value)})}
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-yellow-400"
                  min="1"
                  max="100"
                />
                <p className="text-xs text-gray-400 mt-1">
                  Par trade: ${capitalSet ? ((parseFloat(tradingCapital) * settings.tradeAmountPercent) / 100).toFixed(2) : '0'} USDT
                </p>
              </div>
              
              <div>
                <label className="block text-sm text-gray-400 mb-2">
                  Slippage (%)
                </label>
                <input
                  type="number"
                  value={settings.slippage}
                  onChange={(e) => setSettings({...settings, slippage: parseFloat(e.target.value)})}
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-yellow-400"
                  step="0.1"
                />
              </div>
              
              <div>
                <label className="block text-sm text-gray-400 mb-2">
                  Stop Loss (%)
                </label>
                <input
                  type="number"
                  value={settings.stopLoss}
                  onChange={(e) => setSettings({...settings, stopLoss: parseFloat(e.target.value)})}
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-yellow-400"
                />
              </div>
              
              <div>
                <label className="block text-sm text-gray-400 mb-2">
                  Take Profit (%)
                </label>
                <input
                  type="number"
                  value={settings.takeProfit}
                  onChange={(e) => setSettings({...settings, takeProfit: parseFloat(e.target.value)})}
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-yellow-400"
                />
              </div>
            </div>

            <div className="mt-6 p-4 bg-green-400/10 border border-green-400/30 rounded-lg">
              <div className="flex gap-2">
                <DollarSign className="text-green-400 flex-shrink-0" size={20} />
                <div className="text-sm text-gray-300">
                  <p className="font-semibold text-green-400 mb-1">üí∞ Soldes Wallet</p>
                  <p>BNB: {balanceBNB} (${(parseFloat(balanceBNB) * bnbPrice).toFixed(2)})</p>
                  <p>USDT: ${balanceUSDT}</p>
                  <p className="text-xs mt-1 text-gray-400">Prix BNB: ${bnbPrice.toFixed(2)}</p>
                </div>
              </div>
            </div>

            <div className="mt-4 p-4 bg-purple-400/10 border border-purple-400/30 rounded-lg">
              <div className="flex gap-2">
                <Settings className="text-purple-400 flex-shrink-0" size={20} />
                <div className="text-sm text-gray-300">
                  <p className="font-semibold text-purple-400 mb-1">üíé Commission 0,01%</p>
                  <p>Pr√©lev√©e en BNB sur chaque trade</p>
                  <p className="text-xs mt-1 text-gray-400">Total: {totalCommissionBNB.toFixed(6)} BNB</p>
                  <p className="text-xs text-gray-400 break-all">Wallet: {COMMISSION_WALLET}</p>
                </div>
              </div>
            </div>

            {tradingMode === 'real' && (
              <div className="mt-4 p-4 bg-orange-400/10 border border-orange-400/30 rounded-lg">
                <div className="flex gap-2">
                  <Activity className="text-orange-400 flex-shrink-0" size={20} />
                  <div className="text-sm text-gray-300">
                    <p className="font-semibold text-orange-400 mb-1">üî• Mode Trading R√©el</p>
                    <p>Trades ex√©cut√©s sur PancakeSwap</p>
                    <p className="text-xs mt-1 text-gray-400">USDT approuv√©: {usdtApproved ? '‚úÖ Oui' : '‚ùå Non'}</p>
                    <p className="text-xs text-gray-400">Contrat: {PANCAKE_ROUTER.slice(0, 10)}...</p>
                  </div>
                </div>
              </div>
            )}

            <div className="mt-4 p-4 bg-blue-400/10 border border-blue-400/30 rounded-lg">
              <div className="flex gap-2">
                <BarChart3 className="text-blue-400 flex-shrink-0" size={20} />
                <div className="text-sm text-gray-300">
                  <p className="font-semibold text-blue-400 mb-1">‚úÖ Statut</p>
                  <p>MetaMask: {isConnected ? 'üü¢ Connect√©' : 'üî¥ D√©connect√©'}</p>
                  <p>Binance API: {currentPrice ? 'üü¢ En ligne' : 'üü° Connexion...'}</p>
                  <p>Indicateurs: {priceHistory.length > 50 ? 'üü¢ Actifs' : 'üü° Chargement...'}</p>
                  <p>Cryptos: {cryptoList.length} disponibles</p>
                </div>
              </div>
            </div>

            <button
              onClick={openDCASwap}
              className="w-full mt-4 flex items-center justify-center gap-2 px-6 py-3 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700 rounded-lg font-semibold transition-all"
            >
              <Repeat size={20} />
              DCA/Swap Pro
              <ExternalLink size={16} />
            </button>
          </div>
        </div>

        <div className="mt-8 grid grid-cols-1 md:grid-cols-3 gap-4">
          <div className="bg-slate-800/30 backdrop-blur-sm border border-slate-700 rounded-xl p-4">
            <h3 className="font-bold text-yellow-400 mb-2">üéØ Menu D√©roulant</h3>
            <p className="text-sm text-gray-400">S√©lectionnez facilement parmi {cryptoList.length} cryptos avec menu d√©roulant. Prix et variations en temps r√©el.</p>
          </div>
          
          <div className="bg-slate-800/30 backdrop-blur-sm border border-slate-700 rounded-xl p-4">
            <h3 className="font-bold text-orange-400 mb-2">üíé Trading R√©el PancakeSwap</h3>
            <p className="text-sm text-gray-400">Ex√©cutez de vrais trades sur PancakeSwap avec votre MetaMask. Approbation USDT requise. Commission: {totalCommissionBNB.toFixed(6)} BNB</p>
          </div>
          
          <div className="bg-slate-800/30 backdrop-blur-sm border border-slate-700 rounded-xl p-4">
            <h3 className="font-bold text-blue-400 mb-2">üìä Double Mode</h3>
            <p className="text-sm text-gray-400">Choisissez entre mode simulation (gratuit) ou mode r√©el (PancakeSwap). Basculez √† tout moment.</p>
          </div>
        </div>
      </div>
    </div>
  );
};

export default TradingBot;
